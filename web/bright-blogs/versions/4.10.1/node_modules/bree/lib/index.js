"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var EventEmitter = require('events');

var fs = require('fs');

var _require = require('path'),
    resolve = _require.resolve;

var pWaitFor = require('p-wait-for');

var combineErrors = require('combine-errors');

var debug = require('debug')('bree');

var isSANB = require('is-string-and-not-blank');

var isValidPath = require('is-valid-path');

var later = require('@breejs/later');

var threads = require('bthreads');

var _require2 = require('safe-timers'),
    setTimeout = _require2.setTimeout,
    setInterval = _require2.setInterval;

var _require3 = require('./job-utils'),
    isSchedule = _require3.isSchedule,
    getName = _require3.getName,
    getHumanToMs = _require3.getHumanToMs,
    parseValue = _require3.parseValue,
    getJobNames = _require3.getJobNames;

var buildJob = require('./job-builder');

var validateJob = require('./job-validator'); // Bthreads requires us to do this for web workers (see bthreads docs for insight)


threads.Buffer = Buffer; // Instead of `threads.browser` checks below, we previously used this boolean
// const hasFsStatSync = typeof fs === 'object' && typeof fs.statSync === 'function';

var Bree = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2.default)(Bree, _EventEmitter);

  var _super = _createSuper(Bree);

  function Bree(config) {
    var _this;

    (0, _classCallCheck2.default)(this, Bree);
    _this = _super.call(this);
    _this.config = _objectSpread({
      // We recommend using Cabin for logging
      // <https://cabinjs.com>
      logger: console,
      // Set this to `false` to prevent requiring a root directory of jobs
      // (e.g. if your jobs are not all in one directory)
      root: threads.browser
      /* istanbul ignore next */
      ? threads.resolve('jobs') : resolve('jobs'),
      // Default timeout for jobs
      // (set this to `false` if you do not wish for a default timeout to be set)
      timeout: 0,
      // Default interval for jobs
      // (set this to `0` for no interval, and > 0 for a default interval to be set)
      interval: 0,
      // This is an Array of your job definitions (see README for examples)
      jobs: [],
      // <https://breejs.github.io/later/parsers.html#cron>
      // (can be overridden on a job basis with same prop name)
      hasSeconds: false,
      // <https://github.com/Airfooox/cron-validate>
      cronValidate: {},
      // If you set a value > 0 here, then it will terminate workers after this time (ms)
      closeWorkerAfterMs: 0,
      // Could also be mjs if desired
      // (this is the default extension if you just specify a job's name without ".js" or ".mjs")
      defaultExtension: 'js',
      // Default worker options to pass to ~`new Worker`~ `new threads.Worker`
      // (can be overridden on a per job basis)
      // <https://nodejs.org/api/worker_threads.html#worker_threads_new_worker_filename_options>
      worker: {},
      // Custom handler to execute when error events are emitted by the workers or when they exit
      // with non-zero code
      // pass in a callback function with following signature: `(error, workerMetadata) => { // custom handling here }`
      errorHandler: null,
      // Custom handler executed when a `message` event is received from a worker.
      // A special 'done' even is also broadcasted while leaving worker shutdown logic in place.
      workerMessageHandler: null,
      //
      // if you set this to `true`, then a second arg is passed to log output
      // and it will be an Object with `{ worker: Object }` set, for example:
      // (see the documentation at <https://nodejs.org/api/worker_threads.html> for more insight)
      //
      // logger.info('...', {
      //   worker: {
      //     isMainThread: Boolean
      //     resourceLimits: Object,
      //     threadId: String
      //   }
      // });
      //
      outputWorkerMetadata: false
    }, config); //
    // if `hasSeconds` is `true` then ensure that
    // `cronValidate` object has `override` object with `useSeconds` set to `true`
    // <https://github.com/breejs/bree/issues/7>
    //

    if (_this.config.hasSeconds) {
      _this.config.cronValidate = _objectSpread(_objectSpread({}, _this.config.cronValidate), {}, {
        preset: _this.config.cronValidate && _this.config.cronValidate.preset ? _this.config.cronValidate.preset : 'default',
        override: _objectSpread(_objectSpread({}, _this.config.cronValidate && _this.config.cronValidate.override ? _this.config.cronValidate.override : {}), {}, {
          useSeconds: true
        })
      });
    }

    debug('config', _this.config);
    _this.closeWorkerAfterMs = {};
    _this.workers = {};
    _this.timeouts = {};
    _this.intervals = {};
    _this.isSchedule = isSchedule;
    _this.getWorkerMetadata = _this.getWorkerMetadata.bind((0, _assertThisInitialized2.default)(_this));
    _this.run = _this.run.bind((0, _assertThisInitialized2.default)(_this));
    _this.start = _this.start.bind((0, _assertThisInitialized2.default)(_this));
    _this.stop = _this.stop.bind((0, _assertThisInitialized2.default)(_this));
    _this.add = _this.add.bind((0, _assertThisInitialized2.default)(_this));
    _this.remove = _this.remove.bind((0, _assertThisInitialized2.default)(_this));
    _this.validateJob = validateJob;
    _this.getName = getName;
    _this.getHumanToMs = getHumanToMs;
    _this.parseValue = parseValue; // Validate root (sync check)

    if (isSANB(_this.config.root)) {
      /* istanbul ignore next */
      if (!threads.browser && isValidPath(_this.config.root)) {
        var stats = fs.statSync(_this.config.root);

        if (!stats.isDirectory()) {
          throw new Error("Root directory of ".concat(_this.config.root, " does not exist"));
        }
      }
    } // Validate timeout


    _this.config.timeout = _this.parseValue(_this.config.timeout);
    debug('timeout', _this.config.timeout); // Validate interval

    _this.config.interval = _this.parseValue(_this.config.interval);
    debug('interval', _this.config.interval); //
    // if `this.config.jobs` is an empty array
    // then we should try to load `jobs/index.js`
    //

    if (_this.config.root && (!Array.isArray(_this.config.jobs) || _this.config.jobs.length === 0)) {
      try {
        _this.config.jobs = threads.require(_this.config.root);
      } catch (err) {
        _this.config.logger.error(err);
      }
    } //
    // validate jobs
    //


    if (!Array.isArray(_this.config.jobs)) {
      throw new TypeError('Jobs must be an Array');
    } // Provide human-friendly errors for complex configurations


    var errors = [];
    /*
    Jobs = [
      'name',
      { name: 'boot' },
      { name: 'timeout', timeout: ms('3s') },
      { name: 'cron', cron: '* * * * *' },
      { name: 'cron with timeout', timeout: '3s', cron: '* * * * *' },
      { name: 'interval', interval: ms('4s') }
      { name: 'interval', path: '/some/path/to/script.js', interval: ms('4s') },
      { name: 'timeout', timeout: 'three minutes' },
      { name: 'interval', interval: 'one minute' },
      { name: 'timeout', timeout: '3s' },
      { name: 'interval', interval: '30d' },
      { name: 'schedule object', interval: { schedules: [] } }
    ]
    */

    for (var i = 0; i < _this.config.jobs.length; i++) {
      try {
        var names = getJobNames(_this.config.jobs, i);
        validateJob(_this.config.jobs[i], i, names, _this.config);
        _this.config.jobs[i] = buildJob(_this.config.jobs[i], _this.config);
      } catch (err) {
        errors.push(err);
      }
    } // If there were any errors then throw them


    if (errors.length > 0) {
      throw combineErrors(errors);
    }

    debug('this.config.jobs', _this.config.jobs);
    return _this;
  }

  (0, _createClass2.default)(Bree, [{
    key: "getWorkerMetadata",
    value: function getWorkerMetadata(name) {
      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var job = this.config.jobs.find(function (j) {
        return j.name === name;
      });

      if (!job) {
        throw new Error("Job \"".concat(name, "\" does not exist"));
      }

      if (!this.config.outputWorkerMetadata && !job.outputWorkerMetadata) {
        return meta && (typeof meta.err !== 'undefined' || typeof meta.message !== 'undefined') ? meta : undefined;
      }

      return this.workers[name] ? _objectSpread(_objectSpread({}, meta), {}, {
        worker: {
          isMainThread: this.workers[name].isMainThread,
          resourceLimits: this.workers[name].resourceLimits,
          threadId: this.workers[name].threadId
        }
      }) : meta;
    }
  }, {
    key: "run",
    value: function run(name) {
      var _this2 = this;

      debug('run', name);

      if (name) {
        var job = this.config.jobs.find(function (j) {
          return j.name === name;
        });

        if (!job) {
          throw new Error("Job \"".concat(name, "\" does not exist"));
        }

        if (this.workers[name]) {
          return this.config.logger.warn(new Error("Job \"".concat(name, "\" is already running")), this.getWorkerMetadata(name));
        }

        debug('starting worker', name);

        var object = _objectSpread(_objectSpread(_objectSpread({}, this.config.worker ? this.config.worker : {}), job.worker ? job.worker : {}), {}, {
          workerData: _objectSpread(_objectSpread({
            job: job
          }, this.config.worker && this.config.worker.workerData ? this.config.worker.workerData : {}), job.worker && job.worker.workerData ? job.worker.workerData : {})
        });

        this.workers[name] = new threads.Worker(job.path, object);
        this.emit('worker created', name);
        debug('worker started', name);
        var prefix = "Worker for job \"".concat(name, "\"");
        this.workers[name].on('online', function () {
          // If we specified a value for `closeWorkerAfterMs`
          // then we need to terminate it after that execution time
          var closeWorkerAfterMs = Number.isFinite(job.closeWorkerAfterMs) ? job.closeWorkerAfterMs : _this2.config.closeWorkerAfterMs;

          if (Number.isFinite(closeWorkerAfterMs) && closeWorkerAfterMs > 0) {
            debug('worker has close set', name, closeWorkerAfterMs);
            _this2.closeWorkerAfterMs[name] = setTimeout(function () {
              /* istanbul ignore else */
              if (_this2.workers[name]) {
                debug('worker has been terminated', name);

                _this2.workers[name].terminate();
              }
            }, closeWorkerAfterMs);
          }

          _this2.config.logger.info("".concat(prefix, " online"), _this2.getWorkerMetadata(name));
        });
        this.workers[name].on('message', function (message) {
          var metadata = _this2.getWorkerMetadata(name, {
            message: message
          });

          if (_this2.config.workerMessageHandler) {
            _this2.config.workerMessageHandler(_objectSpread({
              name: name
            }, metadata));
          } else if (message === 'done') {
            _this2.config.logger.info("".concat(prefix, " signaled completion"), metadata);
          } else {
            _this2.config.logger.info("".concat(prefix, " sent a message"), metadata);
          }

          if (message === 'done') {
            _this2.workers[name].removeAllListeners('message');

            _this2.workers[name].removeAllListeners('exit');

            _this2.workers[name].terminate();

            delete _this2.workers[name];
          }
        }); // NOTE: you cannot catch messageerror since it is a Node internal
        //       (if anyone has any idea how to catch this in tests let us know)

        /* istanbul ignore next */

        this.workers[name].on('messageerror', function (err) {
          if (_this2.config.errorHandler) {
            _this2.config.errorHandler(err, _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name, {
              err: err
            })));
          } else {
            _this2.config.logger.error("".concat(prefix, " had a message error"), _this2.getWorkerMetadata(name, {
              err: err
            }));
          }
        });
        this.workers[name].on('error', function (err) {
          if (_this2.config.errorHandler) {
            _this2.config.errorHandler(err, _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name, {
              err: err
            })));
          } else {
            _this2.config.logger.error("".concat(prefix, " had an error"), _this2.getWorkerMetadata(name, {
              err: err
            }));
          }
        });
        this.workers[name].on('exit', function (code) {
          var level = code === 0 ? 'info' : 'error';

          if (level === 'error' && _this2.config.errorHandler) {
            _this2.config.errorHandler(new Error("".concat(prefix, " exited with code ").concat(code)), _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name)));
          } else {
            _this2.config.logger[level]("".concat(prefix, " exited with code ").concat(code), _this2.getWorkerMetadata(name));
          }

          delete _this2.workers[name];

          _this2.emit('worker deleted', name);
        });
        return;
      }

      var _iterator = _createForOfIteratorHelper(this.config.jobs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _job = _step.value;
          this.run(_job.name);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "start",
    value: function start(name) {
      var _this3 = this;

      debug('start', name);

      if (name) {
        var job = this.config.jobs.find(function (j) {
          return j.name === name;
        });

        if (!job) {
          throw new Error("Job ".concat(name, " does not exist"));
        }

        if (this.timeouts[name] || this.intervals[name] || this.workers[name]) {
          return this.config.logger.warn(new Error("Job \"".concat(name, "\" is already started")));
        }

        debug('job', job); // Check for date and if it is in the past then don't run it

        if (job.date instanceof Date) {
          debug('job date', job);

          if (job.date.getTime() < Date.now()) {
            debug('job date was in the past');
            return;
          }

          this.timeouts[name] = setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else {
              debug('job.date was scheduled to run only once', job);
            }

            delete _this3.timeouts[name];
          }, job.date.getTime() - Date.now());
          return;
        } // This is only complex because both timeout and interval can be a schedule


        if (this.isSchedule(job.timeout)) {
          debug('job timeout is schedule', job);
          this.timeouts[name] = later.setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            }

            delete _this3.timeouts[name];
          }, job.timeout);
          return;
        }

        if (Number.isFinite(job.timeout)) {
          debug('job timeout is finite', job);
          this.timeouts[name] = setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job.interval);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            }

            delete _this3.timeouts[name];
          }, job.timeout);
        } else if (this.isSchedule(job.interval)) {
          debug('job.interval is schedule', job);
          this.intervals[name] = later.setInterval(function () {
            return _this3.run(name);
          }, job.interval);
        } else if (Number.isFinite(job.interval) && job.interval > 0) {
          debug('job.interval is finite', job);
          this.intervals[name] = setInterval(function () {
            return _this3.run(name);
          }, job.interval);
        }

        return;
      }

      var _iterator2 = _createForOfIteratorHelper(this.config.jobs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _job2 = _step2.value;
          this.start(_job2.name);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
        var _this4 = this;

        var _iterator3, _step3, job;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!name) {
                  _context.next = 6;
                  break;
                }

                if (this.timeouts[name]) {
                  if ((0, _typeof2.default)(this.timeouts[name]) === 'object' && typeof this.timeouts[name].clear === 'function') {
                    this.timeouts[name].clear();
                  }

                  delete this.timeouts[name];
                }

                if (this.intervals[name]) {
                  if ((0, _typeof2.default)(this.intervals[name]) === 'object' && typeof this.intervals[name].clear === 'function') {
                    this.intervals[name].clear();
                  }

                  delete this.intervals[name];
                }

                if (this.workers[name]) {
                  this.workers[name].once('message', function (message) {
                    if (message === 'cancelled') {
                      _this4.config.logger.info("Gracefully cancelled worker for job \"".concat(name, "\""), _this4.getWorkerMetadata(name));

                      _this4.workers[name].terminate();
                    }
                  });
                  this.workers[name].postMessage('cancel');
                }

                if (this.closeWorkerAfterMs[name]) {
                  if ((0, _typeof2.default)(this.closeWorkerAfterMs[name]) === 'object' && typeof this.closeWorkerAfterMs[name].clear === 'function') {
                    this.closeWorkerAfterMs[name].clear();
                  }

                  delete this.closeWorkerAfterMs[name];
                }

                return _context.abrupt("return", pWaitFor(function () {
                  return _this4.workers[name] === undefined;
                }));

              case 6:
                _iterator3 = _createForOfIteratorHelper(this.config.jobs);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    job = _step3.value;
                    this.stop(job.name);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                return _context.abrupt("return", pWaitFor(function () {
                  return Object.keys(_this4.workers).length === 0;
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function stop(_x) {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }, {
    key: "add",
    value: function add(jobs) {
      //
      // make sure jobs is an array
      //
      if (!Array.isArray(jobs)) {
        jobs = [jobs];
      }

      var errors = [];

      var _iterator4 = _createForOfIteratorHelper(jobs.entries()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
              i = _step4$value[0],
              job_ = _step4$value[1];

          try {
            var names = [].concat((0, _toConsumableArray2.default)(getJobNames(jobs, i)), (0, _toConsumableArray2.default)(getJobNames(this.config.jobs)));
            validateJob(job_, i, names, this.config);
            var job = buildJob(job_, this.config);
            this.config.jobs.push(job);
          } catch (err) {
            errors.push(err);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      debug('jobs added', this.config.jobs); // If there were any errors then throw them

      if (errors.length > 0) {
        throw combineErrors(errors);
      }
    }
  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name) {
        var job;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                job = this.config.jobs.find(function (j) {
                  return j.name === name;
                });

                if (job) {
                  _context2.next = 3;
                  break;
                }

                throw new Error("Job \"".concat(name, "\" does not exist"));

              case 3:
                _context2.next = 5;
                return this.stop(name);

              case 5:
                this.config.jobs = this.config.jobs.filter(function (j) {
                  return j.name !== name;
                });

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function remove(_x2) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }]);
  return Bree;
}(EventEmitter); // Expose bthreads (useful for tests)
// https://github.com/chjj/bthreads#api


Bree.threads = {
  backend: threads.backend,
  browser: threads.browser,
  location: threads.location,
  filename: threads.filename,
  dirname: threads.dirname,
  require: threads.require,
  resolve: threads.resolve,
  exit: threads.exit,
  cores: threads.cores
};
module.exports = Bree;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiZnMiLCJyZXNvbHZlIiwicFdhaXRGb3IiLCJjb21iaW5lRXJyb3JzIiwiZGVidWciLCJpc1NBTkIiLCJpc1ZhbGlkUGF0aCIsImxhdGVyIiwidGhyZWFkcyIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImlzU2NoZWR1bGUiLCJnZXROYW1lIiwiZ2V0SHVtYW5Ub01zIiwicGFyc2VWYWx1ZSIsImdldEpvYk5hbWVzIiwiYnVpbGRKb2IiLCJ2YWxpZGF0ZUpvYiIsIkJ1ZmZlciIsIkJyZWUiLCJjb25maWciLCJsb2dnZXIiLCJjb25zb2xlIiwicm9vdCIsImJyb3dzZXIiLCJ0aW1lb3V0IiwiaW50ZXJ2YWwiLCJqb2JzIiwiaGFzU2Vjb25kcyIsImNyb25WYWxpZGF0ZSIsImNsb3NlV29ya2VyQWZ0ZXJNcyIsImRlZmF1bHRFeHRlbnNpb24iLCJ3b3JrZXIiLCJlcnJvckhhbmRsZXIiLCJ3b3JrZXJNZXNzYWdlSGFuZGxlciIsIm91dHB1dFdvcmtlck1ldGFkYXRhIiwicHJlc2V0Iiwib3ZlcnJpZGUiLCJ1c2VTZWNvbmRzIiwid29ya2VycyIsInRpbWVvdXRzIiwiaW50ZXJ2YWxzIiwiZ2V0V29ya2VyTWV0YWRhdGEiLCJiaW5kIiwicnVuIiwic3RhcnQiLCJzdG9wIiwiYWRkIiwicmVtb3ZlIiwic3RhdHMiLCJzdGF0U3luYyIsImlzRGlyZWN0b3J5IiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJlcnIiLCJlcnJvciIsIlR5cGVFcnJvciIsImVycm9ycyIsImkiLCJuYW1lcyIsInB1c2giLCJuYW1lIiwibWV0YSIsImpvYiIsImZpbmQiLCJqIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsImlzTWFpblRocmVhZCIsInJlc291cmNlTGltaXRzIiwidGhyZWFkSWQiLCJ3YXJuIiwib2JqZWN0Iiwid29ya2VyRGF0YSIsIldvcmtlciIsInBhdGgiLCJlbWl0IiwicHJlZml4Iiwib24iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRlcm1pbmF0ZSIsImluZm8iLCJtZXRhZGF0YSIsInJlbW92ZUFsbExpc3RlbmVycyIsImNvZGUiLCJsZXZlbCIsImRhdGUiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsImNsZWFyIiwib25jZSIsInBvc3RNZXNzYWdlIiwiT2JqZWN0Iiwia2V5cyIsImVudHJpZXMiLCJqb2JfIiwiZmlsdGVyIiwiYmFja2VuZCIsImxvY2F0aW9uIiwiZmlsZW5hbWUiLCJkaXJuYW1lIiwiZXhpdCIsImNvcmVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsUUFBRCxDQUE1Qjs7QUFDQSxJQUFNQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxJQUFELENBQWxCOztlQUNvQkEsT0FBTyxDQUFDLE1BQUQsQztJQUFuQkUsTyxZQUFBQSxPOztBQUNSLElBQU1DLFFBQVEsR0FBR0gsT0FBTyxDQUFDLFlBQUQsQ0FBeEI7O0FBQ0EsSUFBTUksYUFBYSxHQUFHSixPQUFPLENBQUMsZ0JBQUQsQ0FBN0I7O0FBQ0EsSUFBTUssS0FBSyxHQUFHTCxPQUFPLENBQUMsT0FBRCxDQUFQLENBQWlCLE1BQWpCLENBQWQ7O0FBQ0EsSUFBTU0sTUFBTSxHQUFHTixPQUFPLENBQUMseUJBQUQsQ0FBdEI7O0FBQ0EsSUFBTU8sV0FBVyxHQUFHUCxPQUFPLENBQUMsZUFBRCxDQUEzQjs7QUFDQSxJQUFNUSxLQUFLLEdBQUdSLE9BQU8sQ0FBQyxlQUFELENBQXJCOztBQUNBLElBQU1TLE9BQU8sR0FBR1QsT0FBTyxDQUFDLFVBQUQsQ0FBdkI7O2dCQUNvQ0EsT0FBTyxDQUFDLGFBQUQsQztJQUFuQ1UsVSxhQUFBQSxVO0lBQVlDLFcsYUFBQUEsVzs7Z0JBUWhCWCxPQUFPLENBQUMsYUFBRCxDO0lBTFRZLFUsYUFBQUEsVTtJ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QTs7O0FBQ0FxQixJQUFJLENBQUNYLE9BQUwsR0FBZTtBQUNiNkYsRUFBQUEsT0FBTyxFQUFFN0YsT0FBTyxDQUFDNkYsT0FESjtBQUViN0UsRUFBQUEsT0FBTyxFQUFFaEIsT0FBTyxDQUFDZ0IsT0FGSjtBQUdiOEUsRUFBQUEsUUFBUSxFQUFFOUYsT0FBTyxDQUFDOEYsUUFITDtBQUliQyxFQUFBQSxRQUFRLEVBQUUvRixPQUFPLENBQUMrRixRQUpMO0FBS2JDLEVBQUFBLE9BQU8sRUFBRWhHLE9BQU8sQ0FBQ2dHLE9BTEo7QUFNYnpHLEVBQUFBLE9BQU8sRUFBRVMsT0FBTyxDQUFDVCxPQU5KO0FBT2JFLEVBQUFBLE9BQU8sRUFBRU8sT0FBTyxDQUFDUCxPQVBKO0FBUWJ3RyxFQUFBQSxJQUFJLEVBQUVqRyxPQUFPLENBQUNpRyxJQVJEO0FBU2JDLEVBQUFBLEtBQUssRUFBRWxHLE9BQU8sQ0FBQ2tHO0FBVEYsQ0FBZjtBQVlBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJ6RixJQUFqQiIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwV2FpdEZvciA9IHJlcXVpcmUoJ3Atd2FpdC1mb3InKTtcbmNvbnN0IGNvbWJpbmVFcnJvcnMgPSByZXF1aXJlKCdjb21iaW5lLWVycm9ycycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdicmVlJyk7XG5jb25zdCBpc1NBTkIgPSByZXF1aXJlKCdpcy1zdHJpbmctYW5kLW5vdC1ibGFuaycpO1xuY29uc3QgaXNWYWxpZFBhdGggPSByZXF1aXJlKCdpcy12YWxpZC1wYXRoJyk7XG5jb25zdCBsYXRlciA9IHJlcXVpcmUoJ0BicmVlanMvbGF0ZXInKTtcbmNvbnN0IHRocmVhZHMgPSByZXF1aXJlKCdidGhyZWFkcycpO1xuY29uc3QgeyBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbCB9ID0gcmVxdWlyZSgnc2FmZS10aW1lcnMnKTtcblxuY29uc3Qge1xuICBpc1NjaGVkdWxlLFxuICBnZXROYW1lLFxuICBnZXRIdW1hblRvTXMsXG4gIHBhcnNlVmFsdWUsXG4gIGdldEpvYk5hbWVzXG59ID0gcmVxdWlyZSgnLi9qb2ItdXRpbHMnKTtcbmNvbnN0IGJ1aWxkSm9iID0gcmVxdWlyZSgnLi9qb2ItYnVpbGRlcicpO1xuY29uc3QgdmFsaWRhdGVKb2IgPSByZXF1aXJlKCcuL2pvYi12YWxpZGF0b3InKTtcblxuLy8gQnRocmVhZHMgcmVxdWlyZXMgdXMgdG8gZG8gdGhpcyBmb3Igd2ViIHdvcmtlcnMgKHNlZSBidGhyZWFkcyBkb2NzIGZvciBpbnNpZ2h0KVxudGhyZWFkcy5CdWZmZXIgPSBCdWZmZXI7XG5cbi8vIEluc3RlYWQgb2YgYHRocmVhZHMuYnJvd3NlcmAgY2hlY2tzIGJlbG93LCB3ZSBwcmV2aW91c2x5IHVzZWQgdGhpcyBib29sZWFuXG4vLyBjb25zdCBoYXNGc1N0YXRTeW5jID0gdHlwZW9mIGZzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZnMuc3RhdFN5bmMgPT09ICdmdW5jdGlvbic7XG5cbmNsYXNzIEJyZWUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLy8gV2UgcmVjb21tZW5kIHVzaW5nIENhYmluIGZvciBsb2dnaW5nXG4gICAgICAvLyA8aHR0cHM6Ly9jYWJpbmpzLmNvbT5cbiAgICAgIGxvZ2dlcjogY29uc29sZSxcbiAgICAgIC8vIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gcHJldmVudCByZXF1aXJpbmcgYSByb290IGRpcmVjdG9yeSBvZiBqb2JzXG4gICAgICAvLyAoZS5nLiBpZiB5b3VyIGpvYnMgYXJlIG5vdCBhbGwgaW4gb25lIGRpcmVjdG9yeSlcbiAgICAgIHJvb3Q6IHRocmVhZHMuYnJvd3NlciAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA/IHRocmVhZHMucmVzb2x2ZSgnam9icycpXG4gICAgICAgIDogcmVzb2x2ZSgnam9icycpLFxuICAgICAgLy8gRGVmYXVsdCB0aW1lb3V0IGZvciBqb2JzXG4gICAgICAvLyAoc2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3UgZG8gbm90IHdpc2ggZm9yIGEgZGVmYXVsdCB0aW1lb3V0IHRvIGJlIHNldClcbiAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAvLyBEZWZhdWx0IGludGVydmFsIGZvciBqb2JzXG4gICAgICAvLyAoc2V0IHRoaXMgdG8gYDBgIGZvciBubyBpbnRlcnZhbCwgYW5kID4gMCBmb3IgYSBkZWZhdWx0IGludGVydmFsIHRvIGJlIHNldClcbiAgICAgIGludGVydmFsOiAwLFxuICAgICAgLy8gVGhpcyBpcyBhbiBBcnJheSBvZiB5b3VyIGpvYiBkZWZpbml0aW9ucyAoc2VlIFJFQURNRSBmb3IgZXhhbXBsZXMpXG4gICAgICBqb2JzOiBbXSxcbiAgICAgIC8vIDxodHRwczovL2JyZWVqcy5naXRodWIuaW8vbGF0ZXIvcGFyc2Vycy5odG1sI2Nyb24+XG4gICAgICAvLyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBqb2IgYmFzaXMgd2l0aCBzYW1lIHByb3AgbmFtZSlcbiAgICAgIGhhc1NlY29uZHM6IGZhbHNlLFxuICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9BaXJmb29veC9jcm9uLXZhbGlkYXRlPlxuICAgICAgY3JvblZhbGlkYXRlOiB7fSxcbiAgICAgIC8vIElmIHlvdSBzZXQgYSB2YWx1ZSA+IDAgaGVyZSwgdGhlbiBpdCB3aWxsIHRlcm1pbmF0ZSB3b3JrZXJzIGFmdGVyIHRoaXMgdGltZSAobXMpXG4gICAgICBjbG9zZVdvcmtlckFmdGVyTXM6IDAsXG4gICAgICAvLyBDb3VsZCBhbHNvIGJlIG1qcyBpZiBkZXNpcmVkXG4gICAgICAvLyAodGhpcyBpcyB0aGUgZGVmYXVsdCBleHRlbnNpb24gaWYgeW91IGp1c3Qgc3BlY2lmeSBhIGpvYidzIG5hbWUgd2l0aG91dCBcIi5qc1wiIG9yIFwiLm1qc1wiKVxuICAgICAgZGVmYXVsdEV4dGVuc2lvbjogJ2pzJyxcbiAgICAgIC8vIERlZmF1bHQgd29ya2VyIG9wdGlvbnMgdG8gcGFzcyB0byB+YG5ldyBXb3JrZXJgfiBgbmV3IHRocmVhZHMuV29ya2VyYFxuICAgICAgLy8gKGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgcGVyIGpvYiBiYXNpcylcbiAgICAgIC8vIDxodHRwczovL25vZGVqcy5vcmcvYXBpL3dvcmtlcl90aHJlYWRzLmh0bWwjd29ya2VyX3RocmVhZHNfbmV3X3dvcmtlcl9maWxlbmFtZV9vcHRpb25zPlxuICAgICAgd29ya2VyOiB7fSxcbiAgICAgIC8vIEN1c3RvbSBoYW5kbGVyIHRvIGV4ZWN1dGUgd2hlbiBlcnJvciBldmVudHMgYXJlIGVtaXR0ZWQgYnkgdGhlIHdvcmtlcnMgb3Igd2hlbiB0aGV5IGV4aXRcbiAgICAgIC8vIHdpdGggbm9uLXplcm8gY29kZVxuICAgICAgLy8gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZm9sbG93aW5nIHNpZ25hdHVyZTogYChlcnJvciwgd29ya2VyTWV0YWRhdGEpID0+IHsgLy8gY3VzdG9tIGhhbmRsaW5nIGhlcmUgfWBcbiAgICAgIGVycm9ySGFuZGxlcjogbnVsbCxcbiAgICAgIC8vIEN1c3RvbSBoYW5kbGVyIGV4ZWN1dGVkIHdoZW4gYSBgbWVzc2FnZWAgZXZlbnQgaXMgcmVjZWl2ZWQgZnJvbSBhIHdvcmtlci5cbiAgICAgIC8vIEEgc3BlY2lhbCAnZG9uZScgZXZlbiBpcyBhbHNvIGJyb2FkY2FzdGVkIHdoaWxlIGxlYXZpbmcgd29ya2VyIHNodXRkb3duIGxvZ2ljIGluIHBsYWNlLlxuICAgICAgd29ya2VyTWVzc2FnZUhhbmRsZXI6IG51bGwsXG4gICAgICAvL1xuICAgICAgLy8gaWYgeW91IHNldCB0aGlzIHRvIGB0cnVlYCwgdGhlbiBhIHNlY29uZCBhcmcgaXMgcGFzc2VkIHRvIGxvZyBvdXRwdXRcbiAgICAgIC8vIGFuZCBpdCB3aWxsIGJlIGFuIE9iamVjdCB3aXRoIGB7IHdvcmtlcjogT2JqZWN0IH1gIHNldCwgZm9yIGV4YW1wbGU6XG4gICAgICAvLyAoc2VlIHRoZSBkb2N1bWVudGF0aW9uIGF0IDxodHRwczovL25vZGVqcy5vcmcvYXBpL3dvcmtlcl90aHJlYWRzLmh0bWw+IGZvciBtb3JlIGluc2lnaHQpXG4gICAgICAvL1xuICAgICAgLy8gbG9nZ2VyLmluZm8oJy4uLicsIHtcbiAgICAgIC8vICAgd29ya2VyOiB7XG4gICAgICAvLyAgICAgaXNNYWluVGhyZWFkOiBCb29sZWFuXG4gICAgICAvLyAgICAgcmVzb3VyY2VMaW1pdHM6IE9iamVjdCxcbiAgICAgIC8vICAgICB0aHJlYWRJZDogU3RyaW5nXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pO1xuICAgICAgLy9cbiAgICAgIG91dHB1dFdvcmtlck1ldGFkYXRhOiBmYWxzZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGlmIGBoYXNTZWNvbmRzYCBpcyBgdHJ1ZWAgdGhlbiBlbnN1cmUgdGhhdFxuICAgIC8vIGBjcm9uVmFsaWRhdGVgIG9iamVjdCBoYXMgYG92ZXJyaWRlYCBvYmplY3Qgd2l0aCBgdXNlU2Vjb25kc2Agc2V0IHRvIGB0cnVlYFxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vYnJlZWpzL2JyZWUvaXNzdWVzLzc+XG4gICAgLy9cbiAgICBpZiAodGhpcy5jb25maWcuaGFzU2Vjb25kcykge1xuICAgICAgdGhpcy5jb25maWcuY3JvblZhbGlkYXRlID0ge1xuICAgICAgICAuLi50aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUsXG4gICAgICAgIHByZXNldDpcbiAgICAgICAgICB0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUgJiYgdGhpcy5jb25maWcuY3JvblZhbGlkYXRlLnByZXNldFxuICAgICAgICAgICAgPyB0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUucHJlc2V0XG4gICAgICAgICAgICA6ICdkZWZhdWx0JyxcbiAgICAgICAgb3ZlcnJpZGU6IHtcbiAgICAgICAgICAuLi4odGhpcy5jb25maWcuY3JvblZhbGlkYXRlICYmIHRoaXMuY29uZmlnLmNyb25WYWxpZGF0ZS5vdmVycmlkZVxuICAgICAgICAgICAgPyB0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUub3ZlcnJpZGVcbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIHVzZVNlY29uZHM6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnY29uZmlnJywgdGhpcy5jb25maWcpO1xuXG4gICAgdGhpcy5jbG9zZVdvcmtlckFmdGVyTXMgPSB7fTtcbiAgICB0aGlzLndvcmtlcnMgPSB7fTtcbiAgICB0aGlzLnRpbWVvdXRzID0ge307XG4gICAgdGhpcy5pbnRlcnZhbHMgPSB7fTtcblxuICAgIHRoaXMuaXNTY2hlZHVsZSA9IGlzU2NoZWR1bGU7XG4gICAgdGhpcy5nZXRXb3JrZXJNZXRhZGF0YSA9IHRoaXMuZ2V0V29ya2VyTWV0YWRhdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZCA9IHRoaXMuYWRkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy52YWxpZGF0ZUpvYiA9IHZhbGlkYXRlSm9iO1xuICAgIHRoaXMuZ2V0TmFtZSA9IGdldE5hbWU7XG4gICAgdGhpcy5nZXRIdW1hblRvTXMgPSBnZXRIdW1hblRvTXM7XG4gICAgdGhpcy5wYXJzZVZhbHVlID0gcGFyc2VWYWx1ZTtcblxuICAgIC8vIFZhbGlkYXRlIHJvb3QgKHN5bmMgY2hlY2spXG4gICAgaWYgKGlzU0FOQih0aGlzLmNvbmZpZy5yb290KSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICghdGhyZWFkcy5icm93c2VyICYmIGlzVmFsaWRQYXRoKHRoaXMuY29uZmlnLnJvb3QpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmModGhpcy5jb25maWcucm9vdCk7XG4gICAgICAgIGlmICghc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb290IGRpcmVjdG9yeSBvZiAke3RoaXMuY29uZmlnLnJvb3R9IGRvZXMgbm90IGV4aXN0YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0aW1lb3V0XG4gICAgdGhpcy5jb25maWcudGltZW91dCA9IHRoaXMucGFyc2VWYWx1ZSh0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICBkZWJ1ZygndGltZW91dCcsIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuXG4gICAgLy8gVmFsaWRhdGUgaW50ZXJ2YWxcbiAgICB0aGlzLmNvbmZpZy5pbnRlcnZhbCA9IHRoaXMucGFyc2VWYWx1ZSh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgZGVidWcoJ2ludGVydmFsJywgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuXG4gICAgLy9cbiAgICAvLyBpZiBgdGhpcy5jb25maWcuam9ic2AgaXMgYW4gZW1wdHkgYXJyYXlcbiAgICAvLyB0aGVuIHdlIHNob3VsZCB0cnkgdG8gbG9hZCBgam9icy9pbmRleC5qc2BcbiAgICAvL1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uZmlnLnJvb3QgJiZcbiAgICAgICghQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5qb2JzKSB8fCB0aGlzLmNvbmZpZy5qb2JzLmxlbmd0aCA9PT0gMClcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmpvYnMgPSB0aHJlYWRzLnJlcXVpcmUodGhpcy5jb25maWcucm9vdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyB2YWxpZGF0ZSBqb2JzXG4gICAgLy9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb25maWcuam9icykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0pvYnMgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgIH1cblxuICAgIC8vIFByb3ZpZGUgaHVtYW4tZnJpZW5kbHkgZXJyb3JzIGZvciBjb21wbGV4IGNvbmZpZ3VyYXRpb25zXG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICAvKlxuICAgIEpvYnMgPSBbXG4gICAgICAnbmFtZScsXG4gICAgICB7IG5hbWU6ICdib290JyB9LFxuICAgICAgeyBuYW1lOiAndGltZW91dCcsIHRpbWVvdXQ6IG1zKCczcycpIH0sXG4gICAgICB7IG5hbWU6ICdjcm9uJywgY3JvbjogJyogKiAqICogKicgfSxcbiAgICAgIHsgbmFtZTogJ2Nyb24gd2l0aCB0aW1lb3V0JywgdGltZW91dDogJzNzJywgY3JvbjogJyogKiAqICogKicgfSxcbiAgICAgIHsgbmFtZTogJ2ludGVydmFsJywgaW50ZXJ2YWw6IG1zKCc0cycpIH1cbiAgICAgIHsgbmFtZTogJ2ludGVydmFsJywgcGF0aDogJy9zb21lL3BhdGgvdG8vc2NyaXB0LmpzJywgaW50ZXJ2YWw6IG1zKCc0cycpIH0sXG4gICAgICB7IG5hbWU6ICd0aW1lb3V0JywgdGltZW91dDogJ3RocmVlIG1pbnV0ZXMnIH0sXG4gICAgICB7IG5hbWU6ICdpbnRlcnZhbCcsIGludGVydmFsOiAnb25lIG1pbnV0ZScgfSxcbiAgICAgIHsgbmFtZTogJ3RpbWVvdXQnLCB0aW1lb3V0OiAnM3MnIH0sXG4gICAgICB7IG5hbWU6ICdpbnRlcnZhbCcsIGludGVydmFsOiAnMzBkJyB9LFxuICAgICAgeyBuYW1lOiAnc2NoZWR1bGUgb2JqZWN0JywgaW50ZXJ2YWw6IHsgc2NoZWR1bGVzOiBbXSB9IH1cbiAgICBdXG4gICAgKi9cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuam9icy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBnZXRKb2JOYW1lcyh0aGlzLmNvbmZpZy5qb2JzLCBpKTtcblxuICAgICAgICB2YWxpZGF0ZUpvYih0aGlzLmNvbmZpZy5qb2JzW2ldLCBpLCBuYW1lcywgdGhpcy5jb25maWcpO1xuXG4gICAgICAgIHRoaXMuY29uZmlnLmpvYnNbaV0gPSBidWlsZEpvYih0aGlzLmNvbmZpZy5qb2JzW2ldLCB0aGlzLmNvbmZpZyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIGFueSBlcnJvcnMgdGhlbiB0aHJvdyB0aGVtXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBjb21iaW5lRXJyb3JzKGVycm9ycyk7XG4gICAgfVxuXG4gICAgZGVidWcoJ3RoaXMuY29uZmlnLmpvYnMnLCB0aGlzLmNvbmZpZy5qb2JzKTtcbiAgfVxuXG4gIGdldFdvcmtlck1ldGFkYXRhKG5hbWUsIG1ldGEgPSB7fSkge1xuICAgIGNvbnN0IGpvYiA9IHRoaXMuY29uZmlnLmpvYnMuZmluZCgoaikgPT4gai5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWpvYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBKb2IgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLm91dHB1dFdvcmtlck1ldGFkYXRhICYmICFqb2Iub3V0cHV0V29ya2VyTWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiBtZXRhICYmXG4gICAgICAgICh0eXBlb2YgbWV0YS5lcnIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBtZXRhLm1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICA/IG1ldGFcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud29ya2Vyc1tuYW1lXVxuICAgICAgPyB7XG4gICAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgICB3b3JrZXI6IHtcbiAgICAgICAgICAgIGlzTWFpblRocmVhZDogdGhpcy53b3JrZXJzW25hbWVdLmlzTWFpblRocmVhZCxcbiAgICAgICAgICAgIHJlc291cmNlTGltaXRzOiB0aGlzLndvcmtlcnNbbmFtZV0ucmVzb3VyY2VMaW1pdHMsXG4gICAgICAgICAgICB0aHJlYWRJZDogdGhpcy53b3JrZXJzW25hbWVdLnRocmVhZElkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA6IG1ldGE7XG4gIH1cblxuICBydW4obmFtZSkge1xuICAgIGRlYnVnKCdydW4nLCBuYW1lKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5jb25maWcuam9icy5maW5kKChqKSA9PiBqLm5hbWUgPT09IG5hbWUpO1xuICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBKb2IgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud29ya2Vyc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubG9nZ2VyLndhcm4oXG4gICAgICAgICAgbmV3IEVycm9yKGBKb2IgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBydW5uaW5nYCksXG4gICAgICAgICAgdGhpcy5nZXRXb3JrZXJNZXRhZGF0YShuYW1lKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkZWJ1Zygnc3RhcnRpbmcgd29ya2VyJywgbmFtZSk7XG4gICAgICBjb25zdCBvYmplY3QgPSB7XG4gICAgICAgIC4uLih0aGlzLmNvbmZpZy53b3JrZXIgPyB0aGlzLmNvbmZpZy53b3JrZXIgOiB7fSksXG4gICAgICAgIC4uLihqb2Iud29ya2VyID8gam9iLndvcmtlciA6IHt9KSxcbiAgICAgICAgd29ya2VyRGF0YToge1xuICAgICAgICAgIGpvYixcbiAgICAgICAgICAuLi4odGhpcy5jb25maWcud29ya2VyICYmIHRoaXMuY29uZmlnLndvcmtlci53b3JrZXJEYXRhXG4gICAgICAgICAgICA/IHRoaXMuY29uZmlnLndvcmtlci53b3JrZXJEYXRhXG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4oam9iLndvcmtlciAmJiBqb2Iud29ya2VyLndvcmtlckRhdGEgPyBqb2Iud29ya2VyLndvcmtlckRhdGEgOiB7fSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2Vyc1tuYW1lXSA9IG5ldyB0aHJlYWRzLldvcmtlcihqb2IucGF0aCwgb2JqZWN0KTtcbiAgICAgIHRoaXMuZW1pdCgnd29ya2VyIGNyZWF0ZWQnLCBuYW1lKTtcbiAgICAgIGRlYnVnKCd3b3JrZXIgc3RhcnRlZCcsIG5hbWUpO1xuXG4gICAgICBjb25zdCBwcmVmaXggPSBgV29ya2VyIGZvciBqb2IgXCIke25hbWV9XCJgO1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdLm9uKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICAgIC8vIElmIHdlIHNwZWNpZmllZCBhIHZhbHVlIGZvciBgY2xvc2VXb3JrZXJBZnRlck1zYFxuICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gdGVybWluYXRlIGl0IGFmdGVyIHRoYXQgZXhlY3V0aW9uIHRpbWVcbiAgICAgICAgY29uc3QgY2xvc2VXb3JrZXJBZnRlck1zID0gTnVtYmVyLmlzRmluaXRlKGpvYi5jbG9zZVdvcmtlckFmdGVyTXMpXG4gICAgICAgICAgPyBqb2IuY2xvc2VXb3JrZXJBZnRlck1zXG4gICAgICAgICAgOiB0aGlzLmNvbmZpZy5jbG9zZVdvcmtlckFmdGVyTXM7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY2xvc2VXb3JrZXJBZnRlck1zKSAmJiBjbG9zZVdvcmtlckFmdGVyTXMgPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ3dvcmtlciBoYXMgY2xvc2Ugc2V0JywgbmFtZSwgY2xvc2VXb3JrZXJBZnRlck1zKTtcbiAgICAgICAgICB0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLndvcmtlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3dvcmtlciBoYXMgYmVlbiB0ZXJtaW5hdGVkJywgbmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBjbG9zZVdvcmtlckFmdGVyTXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyLmluZm8oXG4gICAgICAgICAgYCR7cHJlZml4fSBvbmxpbmVgLFxuICAgICAgICAgIHRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdLm9uKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUsIHsgbWVzc2FnZSB9KTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcud29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy53b3JrZXJNZXNzYWdlSGFuZGxlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSAnZG9uZScpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuaW5mbyhgJHtwcmVmaXh9IHNpZ25hbGVkIGNvbXBsZXRpb25gLCBtZXRhZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyLmluZm8oYCR7cHJlZml4fSBzZW50IGEgbWVzc2FnZWAsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlID09PSAnZG9uZScpIHtcbiAgICAgICAgICB0aGlzLndvcmtlcnNbbmFtZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdtZXNzYWdlJyk7XG4gICAgICAgICAgdGhpcy53b3JrZXJzW25hbWVdLnJlbW92ZUFsbExpc3RlbmVycygnZXhpdCcpO1xuICAgICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy53b3JrZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIE5PVEU6IHlvdSBjYW5ub3QgY2F0Y2ggbWVzc2FnZWVycm9yIHNpbmNlIGl0IGlzIGEgTm9kZSBpbnRlcm5hbFxuICAgICAgLy8gICAgICAgKGlmIGFueW9uZSBoYXMgYW55IGlkZWEgaG93IHRvIGNhdGNoIHRoaXMgaW4gdGVzdHMgbGV0IHVzIGtub3cpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdLm9uKCdtZXNzYWdlZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5lcnJvckhhbmRsZXIoZXJyLCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgLi4udGhpcy5nZXRXb3JrZXJNZXRhZGF0YShuYW1lLCB7IGVyciB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIGAke3ByZWZpeH0gaGFkIGEgbWVzc2FnZSBlcnJvcmAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUsIHsgZXJyIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnNbbmFtZV0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKGVyciwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSwgeyBlcnIgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgJHtwcmVmaXh9IGhhZCBhbiBlcnJvcmAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUsIHsgZXJyIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnNbbmFtZV0ub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGNvZGUgPT09IDAgPyAnaW5mbycgOiAnZXJyb3InO1xuICAgICAgICBpZiAobGV2ZWwgPT09ICdlcnJvcicgJiYgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKFxuICAgICAgICAgICAgbmV3IEVycm9yKGAke3ByZWZpeH0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIC4uLnRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlcltsZXZlbF0oXG4gICAgICAgICAgICBgJHtwcmVmaXh9IGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLndvcmtlcnNbbmFtZV07XG4gICAgICAgIHRoaXMuZW1pdCgnd29ya2VyIGRlbGV0ZWQnLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXMuY29uZmlnLmpvYnMpIHtcbiAgICAgIHRoaXMucnVuKGpvYi5uYW1lKTtcbiAgICB9XG4gIH1cblxuICBzdGFydChuYW1lKSB7XG4gICAgZGVidWcoJ3N0YXJ0JywgbmFtZSk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuY29uZmlnLmpvYnMuZmluZCgoaikgPT4gai5uYW1lID09PSBuYW1lKTtcbiAgICAgIGlmICgham9iKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSm9iICR7bmFtZX0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGltZW91dHNbbmFtZV0gfHwgdGhpcy5pbnRlcnZhbHNbbmFtZV0gfHwgdGhpcy53b3JrZXJzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb2dnZXIud2FybihcbiAgICAgICAgICBuZXcgRXJyb3IoYEpvYiBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IHN0YXJ0ZWRgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkZWJ1Zygnam9iJywgam9iKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGRhdGUgYW5kIGlmIGl0IGlzIGluIHRoZSBwYXN0IHRoZW4gZG9uJ3QgcnVuIGl0XG4gICAgICBpZiAoam9iLmRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYnVnKCdqb2IgZGF0ZScsIGpvYik7XG4gICAgICAgIGlmIChqb2IuZGF0ZS5nZXRUaW1lKCkgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgZGVidWcoJ2pvYiBkYXRlIHdhcyBpbiB0aGUgcGFzdCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dHNbbmFtZV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJ1bihuYW1lKTtcbiAgICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxlKGpvYi5pbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgc2NoZWR1bGUnLCBqb2IpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBsYXRlci5zZXRJbnRlcnZhbChcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy5ydW4obmFtZSksXG4gICAgICAgICAgICAgIGpvYi5pbnRlcnZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZShqb2IuaW50ZXJ2YWwpICYmIGpvYi5pbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgZmluaXRlJywgam9iKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICgpID0+IHRoaXMucnVuKG5hbWUpLFxuICAgICAgICAgICAgICBqb2IuaW50ZXJ2YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdqb2IuZGF0ZSB3YXMgc2NoZWR1bGVkIHRvIHJ1biBvbmx5IG9uY2UnLCBqb2IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVvdXRzW25hbWVdO1xuICAgICAgICB9LCBqb2IuZGF0ZS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIG9ubHkgY29tcGxleCBiZWNhdXNlIGJvdGggdGltZW91dCBhbmQgaW50ZXJ2YWwgY2FuIGJlIGEgc2NoZWR1bGVcbiAgICAgIGlmICh0aGlzLmlzU2NoZWR1bGUoam9iLnRpbWVvdXQpKSB7XG4gICAgICAgIGRlYnVnKCdqb2IgdGltZW91dCBpcyBzY2hlZHVsZScsIGpvYik7XG4gICAgICAgIHRoaXMudGltZW91dHNbbmFtZV0gPSBsYXRlci5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJ1bihuYW1lKTtcbiAgICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxlKGpvYi5pbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgc2NoZWR1bGUnLCBqb2IpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBsYXRlci5zZXRJbnRlcnZhbChcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy5ydW4obmFtZSksXG4gICAgICAgICAgICAgIGpvYi5pbnRlcnZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZShqb2IuaW50ZXJ2YWwpICYmIGpvYi5pbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgZmluaXRlJywgam9iKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICgpID0+IHRoaXMucnVuKG5hbWUpLFxuICAgICAgICAgICAgICBqb2IuaW50ZXJ2YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIHRoaXMudGltZW91dHNbbmFtZV07XG4gICAgICAgIH0sIGpvYi50aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGpvYi50aW1lb3V0KSkge1xuICAgICAgICBkZWJ1Zygnam9iIHRpbWVvdXQgaXMgZmluaXRlJywgam9iKTtcbiAgICAgICAgdGhpcy50aW1lb3V0c1tuYW1lXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucnVuKG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsZShqb2IuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIHNjaGVkdWxlJywgam9iKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdID0gbGF0ZXIuc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICgpID0+IHRoaXMucnVuKG5hbWUpLFxuICAgICAgICAgICAgICBqb2IuaW50ZXJ2YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoam9iLmludGVydmFsKSAmJiBqb2IuaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIGZpbml0ZScsIGpvYi5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXSA9IHNldEludGVydmFsKFxuICAgICAgICAgICAgICAoKSA9PiB0aGlzLnJ1bihuYW1lKSxcbiAgICAgICAgICAgICAgam9iLmludGVydmFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVvdXRzW25hbWVdO1xuICAgICAgICB9LCBqb2IudGltZW91dCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTY2hlZHVsZShqb2IuaW50ZXJ2YWwpKSB7XG4gICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgc2NoZWR1bGUnLCBqb2IpO1xuICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXSA9IGxhdGVyLnNldEludGVydmFsKFxuICAgICAgICAgICgpID0+IHRoaXMucnVuKG5hbWUpLFxuICAgICAgICAgIGpvYi5pbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoam9iLmludGVydmFsKSAmJiBqb2IuaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgIGRlYnVnKCdqb2IuaW50ZXJ2YWwgaXMgZmluaXRlJywgam9iKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnJ1bihuYW1lKSwgam9iLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXMuY29uZmlnLmpvYnMpIHtcbiAgICAgIHRoaXMuc3RhcnQoam9iLm5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0b3AobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBpZiAodGhpcy50aW1lb3V0c1tuYW1lXSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRoaXMudGltZW91dHNbbmFtZV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIHRoaXMudGltZW91dHNbbmFtZV0uY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0c1tuYW1lXS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMudGltZW91dHNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmludGVydmFsc1tuYW1lXSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRoaXMuaW50ZXJ2YWxzW25hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiB0aGlzLmludGVydmFsc1tuYW1lXS5jbGVhciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJ2YWxzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53b3JrZXJzW25hbWVdKSB7XG4gICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS5vbmNlKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gJ2NhbmNlbGxlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgR3JhY2VmdWxseSBjYW5jZWxsZWQgd29ya2VyIGZvciBqb2IgXCIke25hbWV9XCJgLFxuICAgICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJzW25hbWVdLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS5wb3N0TWVzc2FnZSgnY2FuY2VsJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRoaXMuY2xvc2VXb3JrZXJBZnRlck1zW25hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiB0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXS5jbGVhciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuY2xvc2VXb3JrZXJBZnRlck1zW25hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcFdhaXRGb3IoKCkgPT4gdGhpcy53b3JrZXJzW25hbWVdID09PSB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXMuY29uZmlnLmpvYnMpIHtcbiAgICAgIHRoaXMuc3RvcChqb2IubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBXYWl0Rm9yKCgpID0+IE9iamVjdC5rZXlzKHRoaXMud29ya2VycykubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIGFkZChqb2JzKSB7XG4gICAgLy9cbiAgICAvLyBtYWtlIHN1cmUgam9icyBpcyBhbiBhcnJheVxuICAgIC8vXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpvYnMpKSB7XG4gICAgICBqb2JzID0gW2pvYnNdO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbaSwgam9iX10gb2Ygam9icy5lbnRyaWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gW1xuICAgICAgICAgIC4uLmdldEpvYk5hbWVzKGpvYnMsIGkpLFxuICAgICAgICAgIC4uLmdldEpvYk5hbWVzKHRoaXMuY29uZmlnLmpvYnMpXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFsaWRhdGVKb2Ioam9iXywgaSwgbmFtZXMsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgY29uc3Qgam9iID0gYnVpbGRKb2Ioam9iXywgdGhpcy5jb25maWcpO1xuXG4gICAgICAgIHRoaXMuY29uZmlnLmpvYnMucHVzaChqb2IpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2pvYnMgYWRkZWQnLCB0aGlzLmNvbmZpZy5qb2JzKTtcblxuICAgIC8vIElmIHRoZXJlIHdlcmUgYW55IGVycm9ycyB0aGVuIHRocm93IHRoZW1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IGNvbWJpbmVFcnJvcnMoZXJyb3JzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmUobmFtZSkge1xuICAgIGNvbnN0IGpvYiA9IHRoaXMuY29uZmlnLmpvYnMuZmluZCgoaikgPT4gai5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWpvYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBKb2IgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgaXQgYWxzbyBjbG9zZXMgYW55IG9wZW4gd29ya2Vyc1xuICAgIGF3YWl0IHRoaXMuc3RvcChuYW1lKTtcblxuICAgIHRoaXMuY29uZmlnLmpvYnMgPSB0aGlzLmNvbmZpZy5qb2JzLmZpbHRlcigoaikgPT4gai5uYW1lICE9PSBuYW1lKTtcbiAgfVxufVxuXG4vLyBFeHBvc2UgYnRocmVhZHMgKHVzZWZ1bCBmb3IgdGVzdHMpXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hqai9idGhyZWFkcyNhcGlcbkJyZWUudGhyZWFkcyA9IHtcbiAgYmFja2VuZDogdGhyZWFkcy5iYWNrZW5kLFxuICBicm93c2VyOiB0aHJlYWRzLmJyb3dzZXIsXG4gIGxvY2F0aW9uOiB0aHJlYWRzLmxvY2F0aW9uLFxuICBmaWxlbmFtZTogdGhyZWFkcy5maWxlbmFtZSxcbiAgZGlybmFtZTogdGhyZWFkcy5kaXJuYW1lLFxuICByZXF1aXJlOiB0aHJlYWRzLnJlcXVpcmUsXG4gIHJlc29sdmU6IHRocmVhZHMucmVzb2x2ZSxcbiAgZXhpdDogdGhyZWFkcy5leGl0LFxuICBjb3JlczogdGhyZWFkcy5jb3Jlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcmVlO1xuIl19